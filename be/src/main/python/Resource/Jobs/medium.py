# source code from https://github.com/pranavsr97/Image-Processing
import cv2
import numpy as np
import time
from urllib.request import Request, urlopen
import os , sys
import http.server
import socketserver

class MediumHttpRequestHandler(http.server.SimpleHTTPRequestHandler):
	def do_GET(self):
		# Sending an '200 OK' response
		self.send_response(200)

		# Setting the header
		self.send_header("Content-type", "text/html")

		# Whenever using 'send_header', you also have to call 'end_headers'
		self.end_headers()

		# Extract query param
		message = f'Medium job'
		heading = f"<html><head></head><body><h1>{message}</h1></body></html>"
		self.wfile.write(bytes(heading, "utf8"))

		# Some custom HTML code, possibly generated by another function
		message = f'Starting the job.'
		start_msg = f"<html><head></head><body><p>{message}</p></body></html>"
		self.wfile.write(bytes(start_msg, "utf8"))

		start = time.time()
		output = self.zoom()
		duration = time.time() - start

		# Some custom HTML code, possibly generated by another function
		message = f'Finished the job. Took {duration} seconds. Output was {output}'
		end_msg = f"<html><head></head><body><p><br>{message}</br></p></body></html>"
		self.wfile.write(bytes(end_msg, "utf8"))

		return {'status':200, 'output': output}

	def end_headers (self):
		self.send_header('Access-Control-Allow-Origin', '*')
		SimpleHTTPRequestHandler.end_headers(self)

	def zoom(self):

		imgpath = "images/medium.jpg"
		# Pivot co-ordinates and scale are given
		x_coord = int(30)
		y_coord = int(50)
		scale = float(2)

		img=cv2.imread(imgpath)

		tl_x = int(x_coord - (float(1)/float(scale) * float(1)/float(2) * img.shape[1]))
		tl_y = int(y_coord - (float(1)/float(scale) * float(1)/float(2) * img.shape[0]))

		br_x = int(tl_x + (float(1)/float(scale) * img.shape[1]))
		br_y = int(tl_y + (float(1)/float(scale) * img.shape[0]))

		if (tl_x < 0):
			br_x = br_x - tl_x
			tl_x = 0
		if (tl_y < 0):
			br_y = br_y - tl_y
			tl_y = 0

		if (br_x > img.shape[1]):
			tl_x = tl_x - (br_x - img.shape[1])
			br_x = img.shape[1]
		if (br_y > img.shape[0]):
			tl_y = tl_y - (br_y - img.shape[0])
			br_y = img.shape[0]

		# The window is applied over the image to get only the required image portion 
		# roi - region of interest
		roi=img[tl_y:br_y, tl_x:br_x,:]

		# The width and height of this roi is stored
		width1=(roi.shape[1])-1
		height1=(roi.shape[0])-1

		# The width and height of original image is stored
		width2 = img.shape[1]
		height2 = img.shape[0]

		# Width Ratio and Height Ratio are calculated
		width_ratio=float(width1)/float(width2)
		height_ratio=float(height1)/float(height2)

		count=0
		new=[]

		# Every pixel of ther region of interest is traversed
		# We perform bilinear interpolation for the 3 channels (B,G,R) of the image
		for i in range((height2)):
			for j in range((width2)):
				x = int(width_ratio*j)
				y = int(height_ratio*i)
				x_diff = (width_ratio*j) - x
				y_diff = (height_ratio*i) - y

				if (x>=(width1-1) or y>=(height1-1)):
					A_blue = roi[y][x][0]
					A_red = roi[y][x][1]
					A_green = roi[y][x][2]
				else:
					A_blue = roi[y][x][0]
					A_red = roi[y][x][1]
					A_green = roi[y][x][2]

				if ((x+1)>=(width1-1) or (y>=(height1-1))):
					B_blue = roi[y][x][0]
					B_red = roi[y][x][1]
					B_blue = roi[y][x][2]
				else:
					B_blue = roi[y+1][x][0] & 0xff
					B_red = roi[y+1][x][1]
					B_green = roi[y+1][x][2]
				if (x>=(width1-1) or ((y+1)>=(height1-1))):
					C_blue = roi[y][x][0]
					C_red = roi[y][x][1]
					C_green = roi[y][x][2]
				else:
					C_blue = roi[y][x+1][0] & 0xff
					C_red = roi[y][x+1][1]
					C_green = roi[y][x+1][2]
				if ((x+1)>=(width1-1) or (y+1)>=(height1-1)):
					D_blue = roi[y][x][0] & 0xff
					D_red = roi[y][x][1]
					D_green = roi[y][x][2]
				else:
					D_blue = roi[y+1][x+1][0] & 0xff
					D_red = roi[y+1][x+1][1]
					D_green = roi[y+1][x+1][2]

				# Combining all the different channelsn into overall 3 channels
				newimg_blue = (int) ( (A_blue * (1 - x_diff) * (1 - y_diff)) + (B_blue * (x_diff) * (1 - y_diff)) + (C_blue * (y_diff)*(1 - x_diff)) + (D_blue * (x_diff*y_diff)))
				newimg_red = (int) ( (A_red * (1 - x_diff) * (1 - y_diff)) + (B_red * (x_diff) * (1 - y_diff)) + (C_red * (y_diff)*(1 - x_diff)) + (D_red * (x_diff*y_diff)))
				newimg_green = (int) ( (A_green * (1 - x_diff) * (1 - y_diff)) + (B_green * (x_diff) * (1 - y_diff)) + (C_green * (y_diff)*(1 - x_diff)) + (D_green * (x_diff*y_diff)))				

				# Adding the values into the array
				newrow=count//(width2)
				newcol=count%(width2)
				newimg = [newimg_blue,newimg_red,newimg_green]
				if(newcol == 0):
					new.append([])
				new[newrow].append(newimg)
				count+=1

		final_img=np.uint8(new)

		# Final Image is returned
		return final_img

def start_server(PORT):

    my_server = socketserver.TCPServer(("", PORT), MediumHttpRequestHandler)
    my_server.serve_forever()

def main():
    port_num = sys.argv[1]
    start_server(int(port_num))

if __name__ == '__main__':
    main()